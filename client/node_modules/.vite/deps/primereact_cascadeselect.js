"use client";
import {
  TimesIcon
} from "./chunk-JUEFW4ER.js";
import {
  OverlayService
} from "./chunk-C5TGPR2F.js";
import {
  SpinnerIcon
} from "./chunk-D3IIOOAU.js";
import {
  Portal
} from "./chunk-6N2C6HYA.js";
import {
  ChevronDownIcon
} from "./chunk-RTZTTMJ3.js";
import {
  CSSTransition
} from "./chunk-5JDLFEIE.js";
import {
  IconBase
} from "./chunk-VWBAOBJE.js";
import {
  Ripple
} from "./chunk-ER3ARIDS.js";
import "./chunk-SOG3WCGL.js";
import {
  ComponentBase,
  DomHandler,
  ESC_KEY_HANDLING_PRIORITIES,
  IconUtils,
  ObjectUtils,
  PrimeReact,
  PrimeReactContext,
  UniqueComponentId,
  ZIndexUtils,
  classNames,
  localeOption,
  useDisplayOrder,
  useGlobalOnEscapeKey,
  useHandleStyle,
  useMergeProps,
  useMountEffect,
  useOverlayListener,
  useUnmountEffect,
  useUpdateEffect
} from "./chunk-54HUNBMQ.js";
import {
  require_react
} from "./chunk-5HXT6MYD.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/primereact/cascadeselect/cascadeselect.esm.js
var React2 = __toESM(require_react());

// node_modules/primereact/icons/angleright/index.esm.js
var React = __toESM(require_react());
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var AngleRightIcon = React.memo(React.forwardRef(function(inProps, ref) {
  var pti = IconBase.getPTI(inProps);
  return React.createElement("svg", _extends({
    ref,
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, pti), React.createElement("path", {
    d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z",
    fill: "currentColor"
  }));
}));
AngleRightIcon.displayName = "AngleRightIcon";

// node_modules/primereact/cascadeselect/cascadeselect.esm.js
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayLikeToArray$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _unsupportedIterableToArray$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest();
}
var classes = {
  root: function root(_ref) {
    var props = _ref.props, focusedState = _ref.focusedState, overlayVisibleState = _ref.overlayVisibleState, context = _ref.context;
    return classNames("p-cascadeselect p-component p-inputwrapper", {
      "p-disabled": props.disabled,
      "p-invalid": props.invalid,
      "p-variant-filled": props.variant ? props.variant === "filled" : context && context.inputStyle === "filled",
      "p-focus": focusedState,
      "p-inputwrapper-filled": props.value,
      "p-inputwrapper-focus": focusedState || overlayVisibleState
    });
  },
  label: function label(_ref2) {
    var props = _ref2.props, _label = _ref2.label;
    return classNames("p-cascadeselect-label ", {
      "p-placeholder": _label === props.placeholder,
      "p-cascadeselect-label-empty": !props.value && _label === "p-emptylabel"
    });
  },
  list: "p-cascadeselect-panel p-cascadeselect-items",
  sublistWrapper: "p-cascadeselect-sublist-wrapper",
  sublist: "p-cascadeselect-panel p-cascadeselect-items p-cascadeselect-sublist",
  item: function item(_ref3) {
    _ref3.option;
    var isGroup = _ref3.isGroup, isSelected = _ref3.isSelected;
    return classNames("p-cascadeselect-item", {
      "p-cascadeselect-item-group": isGroup,
      "p-cascadeselect-item-active p-highlight": isSelected
    });
  },
  dropdownIcon: "p-cascadeselect-trigger-icon",
  clearIcon: "p-cascadeselect-clear-icon p-clickable",
  loadingIcon: "p-cascadeselect-trigger-icon",
  dropdownButton: "p-cascadeselect-trigger",
  loadingButton: "p-cascadeselect-trigger",
  wrapper: "p-cascadeselect-items-wrapper",
  panel: "p-cascadeselect-panel p-component",
  content: "p-cascadeselect-item-content",
  optionGroupIcon: "p-cascadeselect-group-icon",
  text: "p-cascadeselect-item-text",
  transition: "p-connected-overlay"
};
var styles = "\n@layer primereact {\n    .p-cascadeselect {\n        display: inline-flex;\n        cursor: pointer;\n        position: relative;\n        user-select: none;\n    }\n\n    .p-cascadeselect-trigger {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n    }\n\n    .p-cascadeselect-label {\n        display: block;\n        white-space: nowrap;\n        overflow: hidden;\n        flex: 1 1 auto;\n        width: 1%;\n        text-overflow: ellipsis;\n        cursor: pointer;\n    }\n\n    .p-cascadeselect-label-empty {\n        overflow: hidden;\n        visibility: hidden;\n    }\n\n    .p-cascadeselect .p-cascadeselect-panel {\n        min-width: 100%;\n    }\n\n    .p-cascadeselect-item {\n        cursor: pointer;\n        font-weight: normal;\n        white-space: nowrap;\n    }\n\n    .p-cascadeselect-item-content {\n        display: flex;\n        align-items: center;\n        overflow: hidden;\n        position: relative;\n    }\n\n    .p-cascadeselect-group-icon {\n        margin-left: auto;\n    }\n\n    .p-cascadeselect-items {\n        margin: 0;\n        padding: 0;\n        list-style-type: none;\n        min-width: 100%;\n    }\n\n    .p-fluid .p-cascadeselect {\n        display: flex;\n    }\n\n    .p-fluid .p-cascadeselect .p-cascadeselect-label {\n        width: 1%;\n    }\n\n    .p-cascadeselect-sublist-wrapper {\n        position: absolute;\n        min-width: 100%;\n        z-index: 1;\n        display: none;\n    }\n\n    .p-cascadeselect-item-active {\n        overflow: visible;\n    }\n\n    .p-cascadeselect-item-active > .p-cascadeselect-sublist-wrapper {\n        display: block;\n        left: 100%;\n        top: 0;\n    }\n    .p-cascadeselect-clear-icon {\n        position: absolute;\n        top: 50%;\n        margin-top: -.5rem;\n        right: 3rem;\n    }\n}\n";
var CascadeSelectBase = ComponentBase.extend({
  defaultProps: {
    __TYPE: "CascadeSelect",
    appendTo: null,
    ariaLabelledBy: null,
    autoFocus: false,
    breakpoint: void 0,
    showClear: false,
    className: null,
    dataKey: null,
    disabled: false,
    loadingIcon: null,
    dropdownIcon: null,
    loading: false,
    id: null,
    inputId: null,
    inputRef: null,
    invalid: false,
    variant: null,
    itemTemplate: null,
    name: null,
    onBeforeHide: null,
    onBeforeShow: null,
    onChange: null,
    onGroupChange: null,
    onHide: null,
    onShow: null,
    optionGroupChildren: null,
    optionGroupIcon: null,
    optionGroupLabel: null,
    optionLabel: null,
    optionValue: null,
    options: null,
    panelClassName: null,
    panelStyle: null,
    placeholder: null,
    scrollHeight: "400px",
    style: null,
    tabIndex: null,
    transitionOptions: null,
    value: null,
    children: void 0
  },
  css: {
    classes,
    styles
  }
});
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var CascadeSelectSub = React2.memo(function(props) {
  var mergeProps = useMergeProps();
  var _React$useState = React2.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeOptionState = _React$useState2[0], setActiveOptionState = _React$useState2[1];
  var elementRef = React2.useRef(null);
  var context = React2.useContext(PrimeReactContext);
  var ptm = props.ptm, cx = props.cx;
  var getPTOptions = function getPTOptions2(key, options) {
    return ptm(key, {
      hostName: props.hostName,
      state: _objectSpread$1({}, options)
    });
  };
  var position = function position2() {
    var parentItem = elementRef.current.parentElement.parentElement;
    var containerOffset = DomHandler.getOffset(parentItem);
    var viewport = DomHandler.getViewport();
    var sublistWidth = elementRef.current.offsetParent ? elementRef.current.offsetWidth : DomHandler.getHiddenElementOuterWidth(element);
    var itemOuterWidth = DomHandler.getOuterWidth(parentItem.children[0]);
    if (parseInt(containerOffset.left, 10) + itemOuterWidth + sublistWidth > viewport.width - DomHandler.calculateScrollbarWidth()) {
      elementRef.current.parentElement.style.left = "-100%";
    }
  };
  var onOptionSelect = function onOptionSelect2(event) {
    props.onOptionSelect && props.onOptionSelect(event);
  };
  var _onKeyDown = function onKeyDown(event, option) {
    var listItem = event.currentTarget.parentElement;
    switch (event.key) {
      case "Down":
      case "ArrowDown":
        var nextItem = _findNextItem(listItem);
        if (nextItem) {
          nextItem.children[0].focus();
        }
        break;
      case "Up":
      case "ArrowUp":
        var prevItem = _findPrevItem(listItem);
        if (prevItem) {
          prevItem.children[0].focus();
        }
        break;
      case "Right":
      case "ArrowRight":
        if (isOptionGroup(option)) {
          if (activeOptionState === option) {
            listItem.children[1].children[0].children[0].focus();
          } else {
            setActiveOptionState(option);
          }
        }
        break;
      case "Left":
      case "ArrowLeft":
        setActiveOptionState(null);
        var parentList = event.currentTarget.parentElement.parentElement.previousElementSibling;
        if (parentList) {
          parentList.focus();
        }
        break;
      case "Enter":
        onOptionClick(event, option);
        break;
      case "Tab":
      case "Escape":
        if (props.onPanelHide) {
          props.onPanelHide();
          event.preventDefault();
        }
        break;
    }
    event.preventDefault();
  };
  var _findNextItem = function findNextItem(item2) {
    var nextItem = item2.nextElementSibling;
    return nextItem ? DomHandler.hasClass(nextItem, "p-disabled") || !DomHandler.hasClass(nextItem, "p-cascadeselect-item") ? _findNextItem(nextItem) : nextItem : null;
  };
  var _findPrevItem = function findPrevItem(item2) {
    var prevItem = item2.previousElementSibling;
    return prevItem ? DomHandler.hasClass(prevItem, "p-disabled") || !DomHandler.hasClass(prevItem, "p-cascadeselect-item") ? _findPrevItem(prevItem) : prevItem : null;
  };
  var onOptionClick = function onOptionClick2(event, option) {
    if (isOptionGroup(option)) {
      setActiveOptionState(function(prevActiveOption) {
        return prevActiveOption === option ? null : option;
      });
      if (props.onOptionGroupSelect) {
        props.onOptionGroupSelect({
          originalEvent: event,
          value: option
        });
      }
    } else if (props.onOptionSelect) {
      props.onOptionSelect({
        originalEvent: event,
        value: getOptionValue(option)
      });
    }
  };
  var onOptionGroupSelect = function onOptionGroupSelect2(event) {
    props.onOptionGroupSelect && props.onOptionGroupSelect(event);
  };
  var getOptionLabel = function getOptionLabel2(option) {
    return props.optionLabel ? ObjectUtils.resolveFieldData(option, props.optionLabel) : option;
  };
  var getOptionValue = function getOptionValue2(option) {
    return props.optionValue ? ObjectUtils.resolveFieldData(option, props.optionValue) : option;
  };
  var getOptionGroupLabel = function getOptionGroupLabel2(optionGroup) {
    return props.optionGroupLabel ? ObjectUtils.resolveFieldData(optionGroup, props.optionGroupLabel) : null;
  };
  var getOptionGroupChildren = function getOptionGroupChildren2(optionGroup) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupChildren[props.level]);
  };
  var isOptionGroup = function isOptionGroup2(option) {
    return Object.prototype.hasOwnProperty.call(option, props.optionGroupChildren[props.level]);
  };
  var getOptionLabelToRender = function getOptionLabelToRender2(option) {
    return isOptionGroup(option) ? getOptionGroupLabel(option) : getOptionLabel(option);
  };
  useMountEffect(function() {
    if (props.selectionPath && props.options && !props.dirty) {
      var activeOption = props.options.find(function(o) {
        return props.selectionPath.includes(o);
      });
      activeOption && setActiveOptionState(activeOption);
    }
    if (!props.root) {
      position();
    }
  });
  useUpdateEffect(function() {
    if (!props.parentActive) {
      setActiveOptionState(null);
    }
  }, [props.parentActive]);
  var createSubmenu = function createSubmenu2(option) {
    if (isOptionGroup(option) && activeOptionState === option) {
      var options = getOptionGroupChildren(option);
      var parentActive = activeOptionState === option;
      var level = props.level + 1;
      return React2.createElement(CascadeSelectSub, {
        hostName: props.hostName,
        options,
        className: cx("sublist"),
        selectionPath: props.selectionPath,
        optionLabel: props.optionLabel,
        optionValue: props.optionValue,
        level,
        onOptionSelect,
        onOptionGroupSelect,
        parentActive,
        optionGroupLabel: props.optionGroupLabel,
        optionGroupChildren: props.optionGroupChildren,
        dirty: props.dirty,
        template: props.template,
        onPanelHide: props.onPanelHide,
        ptm,
        cx
      });
    }
    return null;
  };
  var createOption = function createOption2(option, index) {
    var submenu = createSubmenu(option);
    var textProps = mergeProps({
      className: cx("text")
    }, getPTOptions("text"));
    var content = props.template ? ObjectUtils.getJSXElement(props.template, getOptionValue(option)) : React2.createElement("span", textProps, getOptionLabelToRender(option));
    var optionGroupIconProps = mergeProps({
      className: cx("optionGroupIcon")
    }, getPTOptions("optionGroupIcon"));
    var icon = props.optionGroupIcon || React2.createElement(AngleRightIcon, optionGroupIconProps);
    var optionGroup = isOptionGroup(option) && IconUtils.getJSXIcon(icon, _objectSpread$1({}, optionGroupIconProps), {
      props
    });
    var key = getOptionLabelToRender(option) + "_" + index;
    var contentProps = mergeProps({
      className: cx("content"),
      onClick: function onClick(event) {
        return onOptionClick(event, option);
      },
      tabIndex: 0,
      onKeyDown: function onKeyDown(event) {
        return _onKeyDown(event, option);
      }
    }, getPTOptions("content"));
    var isSelected = activeOptionState === option;
    var isGroup = isOptionGroup(option);
    var itemProps = mergeProps({
      className: classNames(option.className, cx("item", {
        option,
        isGroup,
        isSelected
      })),
      style: option.style,
      role: "none",
      "data-p-item-group": isGroup,
      "data-p-highlight": isSelected
    }, getPTOptions("item", {
      selected: isSelected,
      group: isGroup
    }));
    return React2.createElement("li", _extends2({
      key
    }, itemProps), React2.createElement("div", contentProps, content, optionGroup, React2.createElement(Ripple, null)), submenu);
  };
  var createMenu = function createMenu2() {
    return props.options ? props.options.map(createOption) : null;
  };
  var createList = function createList2() {
    var listProps = mergeProps({
      ref: elementRef,
      className: cx(props.level === 0 ? "list" : "sublist", {
        context
      }),
      role: "listbox",
      "aria-orientation": "horizontal"
    }, props.level === 0 ? getPTOptions("list") : getPTOptions("sublist"));
    var submenu = createMenu();
    return React2.createElement("ul", listProps, submenu);
  };
  var createElement3 = function createElement4() {
    var list = createList();
    var listWrapperProps = mergeProps({
      className: cx("sublistWrapper")
    }, getPTOptions("sublistWrapper"));
    return props.level === 0 ? list : React2.createElement("div", listWrapperProps, list);
  };
  var element = createElement3();
  return element;
});
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t["return"] || t["return"]();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var CascadeSelect = React2.memo(React2.forwardRef(function(inProps, ref) {
  var mergeProps = useMergeProps();
  var context = React2.useContext(PrimeReactContext);
  var props = CascadeSelectBase.getProps(inProps, context);
  var _React$useState = React2.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focusedState = _React$useState2[0], setFocusedState = _React$useState2[1];
  var _React$useState3 = React2.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), overlayVisibleState = _React$useState4[0], setOverlayVisibleState = _React$useState4[1];
  var _React$useState5 = React2.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), attributeSelectorState = _React$useState6[0], setAttributeSelectorState = _React$useState6[1];
  var _CascadeSelectBase$se = CascadeSelectBase.setMetaData({
    props,
    state: {
      focused: focusedState,
      overlayVisible: overlayVisibleState,
      attributeSelector: attributeSelectorState
    },
    context: _objectSpread({}, context)
  }), ptm = _CascadeSelectBase$se.ptm, cx = _CascadeSelectBase$se.cx, isUnstyled = _CascadeSelectBase$se.isUnstyled;
  useHandleStyle(CascadeSelectBase.css.styles, isUnstyled, {
    name: "cascadeselect"
  });
  var elementRef = React2.useRef(null);
  var overlayRef = React2.useRef(null);
  var inputRef = React2.useRef(null);
  var labelRef = React2.useRef(null);
  var styleElementRef = React2.useRef(null);
  var dirty = React2.useRef(false);
  var selectionPath = React2.useRef(null);
  var selfChange = React2.useRef(null);
  var _useOverlayListener = useOverlayListener({
    target: elementRef,
    overlay: overlayRef,
    listener: function listener(event, _ref) {
      var valid = _ref.valid, type = _ref.type;
      if (valid) {
        if (context.hideOverlaysOnDocumentScrolling || type === "outside") {
          hide();
        } else if (!DomHandler.isDocument(event.target)) {
          alignOverlay();
        }
      }
    },
    when: overlayVisibleState
  }), _useOverlayListener2 = _slicedToArray(_useOverlayListener, 2), bindOverlayListener = _useOverlayListener2[0], unbindOverlayListener = _useOverlayListener2[1];
  var cascadeSelectOverlayDisplayOrder = useDisplayOrder("cascade-select", overlayVisibleState);
  useGlobalOnEscapeKey({
    callback: function callback() {
      hide();
    },
    when: overlayVisibleState && cascadeSelectOverlayDisplayOrder,
    priority: [ESC_KEY_HANDLING_PRIORITIES.CASCADE_SELECT, cascadeSelectOverlayDisplayOrder]
  });
  var onOptionSelect = function onOptionSelect2(event) {
    if (props.onChange) {
      selfChange.current = true;
      props.onChange({
        originalEvent: event,
        value: event.value
      });
    }
    updateSelectionPath();
    hide();
    DomHandler.focus(inputRef.current);
  };
  var onOptionGroupSelect = function onOptionGroupSelect2(event) {
    dirty.current = true;
    props.onGroupChange && props.onGroupChange(event);
  };
  var getOptionLabel = function getOptionLabel2(option) {
    var label2 = props.optionLabel ? ObjectUtils.resolveFieldData(option, props.optionLabel) : option;
    return label2 || option;
  };
  var getOptionValue = function getOptionValue2(option) {
    return props.optionValue ? ObjectUtils.resolveFieldData(option, props.optionValue) : option;
  };
  var getOptionGroupChildren = function getOptionGroupChildren2(optionGroup, level) {
    return ObjectUtils.resolveFieldData(optionGroup, props.optionGroupChildren[level]);
  };
  var isOptionGroup = function isOptionGroup2(option, level) {
    return Object.prototype.hasOwnProperty.call(option, props.optionGroupChildren[level]);
  };
  var updateSelectionPath = function updateSelectionPath2() {
    var path;
    if (props.value != null && props.options) {
      var _iterator = _createForOfIteratorHelper(props.options), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var option = _step.value;
          path = _findModelOptionInGroup(option, 0);
          if (path) {
            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    selectionPath.current = path;
  };
  var _findModelOptionInGroup = function findModelOptionInGroup(option, level) {
    if (isOptionGroup(option, level)) {
      var selectedOption;
      var _iterator2 = _createForOfIteratorHelper(getOptionGroupChildren(option, level)), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var childOption = _step2.value;
          selectedOption = _findModelOptionInGroup(childOption, level + 1);
          if (selectedOption) {
            selectedOption.unshift(option);
            return selectedOption;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else if (ObjectUtils.equals(props.value, getOptionValue(option), props.dataKey)) {
      return [option];
    }
    return null;
  };
  var _onClick = function onClick(event) {
    if (props.disabled || props.loading) {
      return;
    }
    if (!overlayRef.current || !overlayRef.current.contains(event.target)) {
      DomHandler.focus(inputRef.current);
      overlayVisibleState ? hide() : show();
    }
  };
  var onInputFocus = function onInputFocus2() {
    setFocusedState(true);
  };
  var onInputBlur = function onInputBlur2() {
    setFocusedState(false);
  };
  var onInputKeyDown = function onInputKeyDown2(event) {
    switch (event.which) {
      //down
      case 40:
        if (overlayVisibleState) {
          DomHandler.findSingle(overlayRef.current, '[data-pc-section="item"]').children[0].focus();
        } else if (event.altKey && props.options && props.options.length) {
          show();
        }
        event.preventDefault();
        break;
      //space
      case 32:
        overlayVisibleState ? hide() : show();
        event.preventDefault();
        break;
      //tab
      case 9:
        hide();
        break;
    }
  };
  var onPanelClick = function onPanelClick2(event) {
    OverlayService.emit("overlay-click", {
      originalEvent: event,
      target: elementRef.current
    });
  };
  var show = function show2() {
    props.onBeforeShow && props.onBeforeShow();
    setOverlayVisibleState(true);
  };
  var hide = function hide2() {
    props.onBeforeHide && props.onBeforeHide();
    setOverlayVisibleState(false);
    DomHandler.focus(inputRef.current);
  };
  var onOverlayEnter = function onOverlayEnter2() {
    ZIndexUtils.set("overlay", overlayRef.current, context && context.autoZIndex || PrimeReact.autoZIndex, context && context.zIndex.overlay || PrimeReact.zIndex.overlay);
    DomHandler.addStyles(overlayRef.current, {
      position: "absolute",
      top: "0",
      left: "0"
    });
    alignOverlay();
    if (attributeSelectorState && props.breakpoint) {
      overlayRef.current.setAttribute(attributeSelectorState + "_panel", "");
      createStyle();
    }
  };
  var onOverlayEntered = function onOverlayEntered2() {
    bindOverlayListener();
    props.onShow && props.onShow();
  };
  var onOverlayExit = function onOverlayExit2() {
    unbindOverlayListener();
    dirty.current = false;
  };
  var onOverlayExited = function onOverlayExited2() {
    ZIndexUtils.clear(overlayRef.current);
    props.onHide && props.onHide();
    destroyStyle();
  };
  var alignOverlay = function alignOverlay2() {
    DomHandler.alignOverlay(overlayRef.current, labelRef.current.parentElement, props.appendTo || context && context.appendTo || PrimeReact.appendTo);
  };
  var createStyle = function createStyle2() {
    if (!styleElementRef.current) {
      styleElementRef.current = DomHandler.createInlineStyle(context && context.nonce || PrimeReact.nonce, context && context.styleContainer);
      var selector = "".concat(attributeSelectorState, "_panel");
      var innerHTML = "\n@media screen and (max-width: ".concat(props.breakpoint, ") {\n    .p-cascadeselect-panel[").concat(selector, "] .p-cascadeselect-items-wrapper > ul {\n        max-height: ").concat(props.scrollHeight, ";\n        overflow: ").concat(props.scrollHeight ? "auto" : "", ";\n    }\n\n    .p-cascadeselect-panel[").concat(selector, "] .p-cascadeselect-sublist-wrapper {\n        position:relative;\n        left:0 !important;\n    }\n\n    .p-cascadeselect-panel[").concat(selector, "] .p-cascadeselect-sublist {\n        overflow: hidden !important;\n    }\n\n    .p-cascadeselect-panel[").concat(selector, "] .p-cascadeselect-item-active  .p-cascadeselect-sublist {\n        left: 0;\n        box-shadow: none;\n        border-radius: 0;\n        padding: 0 0 0 calc(var(--inline-spacing) * 2); /* @todo */\n    }\n\n    .p-cascadeselect-panel[").concat(selector, '] .p-cascadeselect-group-icon:before {\n        content: "\\e930";\n    }\n}\n');
      styleElementRef.current.innerHTML = innerHTML;
    }
  };
  var destroyStyle = function destroyStyle2() {
    styleElementRef.current = DomHandler.removeInlineStyle(styleElementRef.current);
  };
  React2.useImperativeHandle(ref, function() {
    return {
      props,
      getElement: function getElement() {
        return elementRef.current;
      },
      getOverlay: function getOverlay() {
        return overlayRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      },
      getLabel: function getLabel() {
        return labelRef.current;
      },
      focus: function focus() {
        return DomHandler.focus(inputRef.current);
      }
    };
  });
  useMountEffect(function() {
    if (props.breakpoint) {
      !attributeSelectorState && setAttributeSelectorState(UniqueComponentId());
    }
    if (props.autoFocus) {
      DomHandler.focus(inputRef.current, props.autoFocus);
    }
    alignOverlay();
  });
  React2.useEffect(function() {
    ObjectUtils.combinedRefs(inputRef, props.inputRef);
  }, [inputRef, props.inputRef]);
  useUpdateEffect(function() {
    updateSelectionPath();
  }, [props.value]);
  useUnmountEffect(function() {
    ZIndexUtils.clear(overlayRef.current);
  });
  var createKeyboardHelper = function createKeyboardHelper2() {
    var value = props.value ? getOptionLabel(props.value) : void 0;
    var hiddenSelectedMessageProps = mergeProps({
      className: "p-hidden-accessible"
    }, ptm("hiddenSelectedMessage"));
    var inputProps = mergeProps(_objectSpread({
      ref: inputRef,
      type: "text",
      id: props.inputId,
      name: props.name,
      defaultValue: value,
      readOnly: true,
      disabled: props.disabled,
      onFocus: onInputFocus,
      onBlur: onInputBlur,
      onKeyDown: function onKeyDown(e) {
        return onInputKeyDown(e);
      },
      tabIndex: props.tabIndex,
      "aria-haspopup": "listbox"
    }, ariaProps), ptm("input"));
    return React2.createElement("div", hiddenSelectedMessageProps, React2.createElement("input", inputProps));
  };
  var clear = function clear2(event) {
    if (props.onChange) {
      selfChange.current = true;
      props.onChange({
        originalEvent: event,
        value: void 0,
        stopPropagation: function stopPropagation() {
          event === null || event === void 0 || event.stopPropagation();
        },
        preventDefault: function preventDefault() {
          event === null || event === void 0 || event.preventDefault();
        },
        target: {
          name: props.name,
          id: props.id,
          value: void 0
        }
      });
    }
  };
  var onClearIconKeyDown = function onClearIconKeyDown2(event) {
    if (event.key === "Enter" || event.code === "Space") {
      clear(event);
      event.preventDefault();
    }
  };
  var createClearIcon = function createClearIcon2() {
    if (props.value != null && props.showClear && !props.disabled) {
      var clearIconProps = mergeProps({
        className: cx("clearIcon"),
        onPointerUp: clear,
        tabIndex: props.tabIndex || "0",
        onKeyDown: onClearIconKeyDown,
        "aria-label": localeOption("clear")
      }, ptm("clearIcon"));
      var icon = props.clearIcon || React2.createElement(TimesIcon, clearIconProps);
      return IconUtils.getJSXIcon(icon, _objectSpread({}, clearIconProps), {
        props
      });
    }
    return null;
  };
  var createLabel = function createLabel2() {
    var label2 = props.value ? getOptionLabel(props.value) : props.placeholder || "p-emptylabel";
    var labelProps = mergeProps({
      ref: labelRef,
      className: cx("label", {
        label: label2
      })
    }, ptm("label", {
      context: _objectSpread({
        label: label2
      }, context)
    }));
    return React2.createElement("span", labelProps, label2);
  };
  var createLoadingIcon = function createLoadingIcon2() {
    var loadingIconProps = mergeProps({
      className: cx("loadingIcon")
    }, ptm("loadingIcon"));
    var icon = props.loadingIcon || React2.createElement(SpinnerIcon, {
      spin: true
    });
    var loadingIcon = IconUtils.getJSXIcon(icon, _objectSpread({}, loadingIconProps), {
      props
    });
    var loadingButtonProps = mergeProps({
      className: cx("loadingButton"),
      role: "button",
      "aria-haspopup": "listbox",
      "aria-expanded": overlayVisibleState
    }, ptm("dropdownButton"));
    return React2.createElement("div", loadingButtonProps, loadingIcon);
  };
  var createDropdownIcon = function createDropdownIcon2() {
    var dropdownIconProps = mergeProps({
      className: cx("dropdownIcon")
    }, ptm("dropdownIcon"));
    var icon = props.dropdownIcon || React2.createElement(ChevronDownIcon, dropdownIconProps);
    var dropdownIcon = IconUtils.getJSXIcon(icon, _objectSpread({}, dropdownIconProps), {
      props
    });
    var dropdownButtonProps = mergeProps({
      className: cx("dropdownButton"),
      role: "button",
      "aria-haspopup": "listbox",
      "aria-expanded": overlayVisibleState
    }, ptm("dropdownButton"));
    return React2.createElement("div", dropdownButtonProps, dropdownIcon);
  };
  var wrapperProps = mergeProps({
    className: cx("wrapper")
  }, ptm("wrapper"));
  var panelProps = mergeProps({
    ref: overlayRef,
    className: classNames(props.panelClassName, cx("panel")),
    style: props.panelStyle,
    onClick: function onClick(e) {
      return onPanelClick(e);
    }
  }, ptm("panel"));
  var createOverlay = function createOverlay2() {
    var transitionProps = mergeProps({
      classNames: cx("transition"),
      "in": overlayVisibleState,
      timeout: {
        enter: 120,
        exit: 100
      },
      options: props.transitionOptions,
      unmountOnExit: true,
      onEnter: onOverlayEnter,
      onEntered: onOverlayEntered,
      onExit: onOverlayExit,
      onExited: onOverlayExited
    }, ptm("transition"));
    var overlay = React2.createElement(CSSTransition, _extends2({
      nodeRef: overlayRef
    }, transitionProps), React2.createElement("div", panelProps, React2.createElement("div", wrapperProps, React2.createElement(CascadeSelectSub, {
      hostName: "CascadeSelect",
      options: props.options,
      selectionPath: selectionPath.current,
      optionGroupIcon: props.optionGroupIcon,
      optionLabel: props.optionLabel,
      optionValue: props.optionValue,
      parentActive: props.value != null,
      level: 0,
      optionGroupLabel: props.optionGroupLabel,
      optionGroupChildren: props.optionGroupChildren,
      onOptionSelect,
      onOptionGroupSelect,
      root: true,
      template: props.itemTemplate,
      onPanelHide: hide,
      ptm,
      cx
    }))));
    return React2.createElement(Portal, {
      element: overlay,
      appendTo: props.appendTo
    });
  };
  var createElement3 = function createElement4() {
    var keyboardHelper = createKeyboardHelper();
    var labelElement = createLabel();
    var clearIcon = createClearIcon();
    var dropdownIcon = props.loading ? createLoadingIcon() : createDropdownIcon();
    var overlay = createOverlay();
    var rootProps = mergeProps({
      id: props.id,
      ref: elementRef,
      className: classNames(props.className, cx("root", {
        focusedState,
        overlayVisibleState,
        context
      })),
      style: props.style,
      onClick: function onClick(e) {
        return _onClick(e);
      }
    }, otherProps, ptm("root"));
    return React2.createElement("div", rootProps, keyboardHelper, labelElement, clearIcon, dropdownIcon, overlay);
  };
  var otherProps = CascadeSelectBase.getOtherProps(props);
  ObjectUtils.reduceKeys(otherProps, DomHandler.DATA_PROPS);
  var ariaProps = ObjectUtils.reduceKeys(otherProps, DomHandler.ARIA_PROPS);
  var element = createElement3();
  return element;
}));
CascadeSelect.displayName = "CascadeSelect";
export {
  CascadeSelect
};
//# sourceMappingURL=primereact_cascadeselect.js.map
